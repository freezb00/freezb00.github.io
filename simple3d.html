<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>ğŸ¨ å…¨èƒ½å…‰å½±ç´ æå®¤</title>
    <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&family=Zcool+KuaiLe&display=swap" rel="stylesheet">
    <style>
        :root {
            --paper-color: #fdfbf7;
            --btn-border: #4a4a4a;
            --accent-color: #ff9f43;
            --tool-active: #3498db;
            --panel-width: 320px;
        }

        body { 
            margin: 0; overflow: hidden; 
            font-family: 'Patrick Hand', 'Zcool KuaiLe', cursive; 
            background-color: var(--paper-color);
            background-image: radial-gradient(#ccc 1px, transparent 1px); 
            background-size: 20px 20px;
            user-select: none;
        }

        #canvas-container { width: 100vw; height: 100vh; }
        
        .panel {
            position: absolute; top: 15px; bottom: 15px;
            background: rgba(255, 255, 255, 0.96);
            border: 3px solid var(--btn-border);
            border-radius: 15px;
            box-shadow: 6px 6px 0px rgba(0,0,0,0.1);
            width: var(--panel-width);
            z-index: 10;
            display: flex; flex-direction: column;
            transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        .panel-content { padding: 15px 20px; overflow-y: auto; flex: 1; }
        .panel-content::-webkit-scrollbar { width: 6px; }
        .panel-content::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }

        #left-panel { left: 15px; }
        #left-panel.collapsed { transform: translateX(calc(-100% - 20px)); }
        #right-panel { right: 15px; box-shadow: -6px 6px 0px rgba(0,0,0,0.1); }
        #right-panel.collapsed { transform: translateX(calc(100% + 20px)); }

        .toggle-btn {
            position: absolute; top: 50%; width: 24px; height: 50px;
            background: #fff; border: 3px solid var(--btn-border);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; font-size: 14px; color: #555;
            transition: background 0.2s; z-index: 11;
        }
        .toggle-btn:hover { background: #ffeb3b; }
        #left-toggle { right: -27px; border-left: none; border-radius: 0 10px 10px 0; box-shadow: 3px 2px 0px rgba(0,0,0,0.1); }
        #right-toggle { left: -27px; border-right: none; border-radius: 10px 0 0 10px; box-shadow: -3px 2px 0px rgba(0,0,0,0.1); }

        h3 { 
            margin: 0 0 10px 0; font-size: 20px; color: #2c3e50; 
            text-align: center; border-bottom: 2px dashed #ccc; padding-bottom: 8px;
        }

        .group-label { 
            font-size: 14px; color: #e67e22; margin-top: 15px; margin-bottom: 6px; 
            display: block; font-weight: bold; border-left: 4px solid #ffcc00; padding-left: 6px;
        }

        .btn-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; }
        .mode-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
        .preset-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }

        button {
            padding: 6px 2px; cursor: pointer; 
            border: 2px solid var(--btn-border);
            background: #fff; border-radius: 8px; 
            font-family: inherit; font-size: 12px;
            transition: all 0.1s ease;
            box-shadow: 2px 2px 0px rgba(0,0,0,0.1);
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        button:hover { transform: translateY(-2px); background: #fff9c4; }
        button:active { transform: translateY(1px); box-shadow: inset 1px 1px 2px rgba(0,0,0,0.1); }
        button.active { background: var(--accent-color); color: white; border-color: #2c3e50; box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2); transform: none; }
        .tool-btn.active { background: var(--tool-active); color: white; }

        .history-bar { display: flex; gap: 5px; margin-bottom: 10px; }
        .history-btn { flex: 1; background: #e3f2fd; border-color: #2196f3; color: #1565c0; font-weight: bold; }
        .history-btn:disabled { opacity: 0.5; cursor: not-allowed; background: #eee; border-color: #ccc; color: #999; transform: none; box-shadow: none; }

        .prop-row { display: flex; align-items: center; gap: 5px; margin-bottom: 5px; }
        .input-group { display: flex; gap: 3px; flex: 1; }
        .input-group input { width: 100%; border: 1px solid #ccc; border-radius: 4px; padding: 4px; font-family: inherit; font-size: 12px; text-align: center; }
        
        .control-row { display: flex; align-items: center; margin-bottom: 8px; font-size: 13px; color: #555; }
        .control-row label { width: 60px; text-align: right; margin-right: 8px;}
        input[type="range"] { flex: 1; height: 8px; appearance: none; background: #eee; border-radius: 4px; border: 1px solid #999; }
        input[type="range"]::-webkit-slider-thumb { appearance: none; width: 14px; height: 14px; background: var(--accent-color); border: 2px solid #333; border-radius: 50%; cursor: pointer; }
        
        #no-selection-mask {
            position: absolute; top: 50px; left: 0; width: 100%; height: 250px;
            background: rgba(255,255,255,0.8); z-index: 20;
            display: flex; justify-content: center; align-items: center;
            color: #888; font-size: 14px; text-align: center;
            pointer-events: none;
        }
        
        #add-light-btn { background: #f1c40f; color: #fff; border-color: #f39c12; grid-column: span 3; font-weight: bold;}
        
        #selection-status {
            font-size: 14px; color: var(--tool-active); text-align: center; 
            margin-bottom: 10px; font-weight: bold; border-bottom: 1px dashed #ccc; padding-bottom: 5px;
        }

        #drop-btn { background-color: #2ecc71; color: white; border-color: #27ae60; width: 100%; margin-top: 5px; font-weight: bold; }
        #drop-btn:hover { background-color: #27ae60; }

        /* ================= æ‹¾è‰²å™¨æ ·å¼ ================= */
        .color-trigger {
            width: 100%; height: 30px; border: 2px solid var(--btn-border); border-radius: 6px;
            cursor: pointer; background-color: #fff; position: relative; box-shadow: inset 0 0 5px rgba(0,0,0,0.1);
        }
        
        /* å¼¹çª—å®¹å™¨ */
        .cp-popup {
            position: absolute; 
            width: 230px; background: #fff; border-radius: 8px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3); border: 1px solid #ccc;
            padding: 10px; z-index: 100; display: none;
            font-family: Arial, sans-serif;
        }
        
        /* Sat/Val æ¿ */
        .cp-sat-val {
            width: 100%; height: 140px; position: relative;
            background: linear-gradient(to right, #fff, rgba(255,255,255,0)), linear-gradient(to top, #000, rgba(0,0,0,0));
            background-color: red; /* Base Hue */
            cursor: crosshair; margin-bottom: 10px; border-radius: 4px; overflow: hidden;
            box-shadow: inset 0 0 2px rgba(0,0,0,0.2);
        }
        .cp-cursor {
            width: 12px; height: 12px; border: 2px solid #fff; border-radius: 50%;
            position: absolute; transform: translate(-6px, -6px); box-shadow: 0 0 3px rgba(0,0,0,0.5); pointer-events: none;
        }

        /* æ§ä»¶æ  (å¸ç®¡ + é¢„è§ˆ + è‰²ç›¸) */
        .cp-controls { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; }
        
        /* å¸ç®¡ */
        .cp-eyedropper {
            width: 24px; height: 24px; cursor: pointer; flex-shrink: 0;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23333' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M17.66 7.93 12 2.27 3.07 11.2c-.48.48-.48 1.25 0 1.73l5.04 5.04c.48.48 1.25.48 1.73 0l8.83-8.83c.96-.96.96-2.52 0-3.48z'/%3E%3Cpath d='M14.12 11.46 9.17 16.41'/%3E%3Cpath d='M6.34 19.24 3.52 22.07'/%3E%3C/svg%3E") no-repeat center/contain;
            transition: transform 0.1s;
        }
        .cp-eyedropper:active { transform: scale(0.9); }
        .cp-eyedropper.disabled { opacity: 0.3; cursor: not-allowed; }

        /* é¢„è§ˆåœˆ */
        .cp-preview {
            width: 24px; height: 24px; border-radius: 50%; border: 1px solid #ccc; flex-shrink: 0;
            box-shadow: inset 0 0 2px rgba(0,0,0,0.1);
        }

        /* è‰²ç›¸æ¡ */
        .cp-hue-rail {
            flex: 1; height: 12px; position: relative;
            background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);
            border-radius: 6px; cursor: pointer;
        }
        .cp-hue-thumb {
            width: 14px; height: 14px; border: 2px solid #fff; background: transparent; border-radius: 50%;
            position: absolute; top: -1px; transform: translateX(-7px); box-shadow: 0 0 2px rgba(0,0,0,0.5); pointer-events: none;
        }

        /* è¾“å…¥åŒºåŸŸå®¹å™¨ */
        .cp-inputs-container { display: flex; align-items: center; gap: 5px; }
        
        /* è¾“å…¥ç»„ */
        .cp-input-group { display: flex; flex-direction: column; align-items: center; flex: 1; }
        .cp-num-input {
            width: 100%; text-align: center; border: 1px solid #ccc; border-radius: 4px; padding: 4px 0; margin-bottom: 2px;
            font-size: 12px;
        }
        .cp-label { 
            font-size: 11px; color: #666; font-weight: bold; cursor: pointer; user-select: none;
            display: flex; align-items: center; gap: 2px;
        }
        .cp-label:hover { color: var(--accent-color); }
        .cp-switch-icon { font-size: 10px; transform: rotate(90deg); display: inline-block; margin-left: 2px; }

    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div id="left-panel" class="panel">
    <div id="left-toggle" class="toggle-btn" title="æŠ˜å ">â—€</div>
    <div class="panel-content">
        <h3>âœ¨ å…‰å½±ç´ æå®¤</h3>
        
        <div class="history-bar">
            <button id="btn-undo" class="history-btn" title="Ctrl+Z">â†©ï¸ æ’¤é”€</button>
            <button id="btn-redo" class="history-btn" title="Ctrl+Y">â†ªï¸ é‡åš</button>
        </div>

        <span class="group-label">ğŸ“¦ åŸºç¡€å‡ ä½•ä½“</span>
        <div class="btn-grid">
            <button id="add-cube">ğŸ“¦ æ–¹å—</button>
            <button id="add-sphere">âš½ çƒçƒ</button>
            <button id="add-cone">ğŸ‰ åœ†é”¥</button>
            <button id="add-cylinder">ğŸ›¢ï¸ åœ†æŸ±</button>
            <button id="add-hemi">ğŸ¥£ åŠçƒ</button>
            <button id="add-capsule">ğŸ’Š èƒ¶å›Š</button>
            <button id="add-torus">ğŸ© ç”œç”œåœˆ</button>
            <button id="add-ring">â­• åœ†ç¯</button>
            <button id="add-lshape">ğŸª‘ Lå‹ä½“</button>
        </div>

        <span class="group-label">ğŸ“ æ£±æŸ±ä¸ç‰¹æ®Šä½“</span>
        <div class="btn-grid">
            <button id="add-pyramid">ğŸ“ å››æ£±é”¥</button>
            <button id="add-prism">ğŸ”º ä¸‰æ£±æŸ±</button>
            <button id="add-wedge">ğŸ“ æ¥”å½¢</button>
            <button id="add-cross">âœš åå­—</button>
            <button id="add-star">â­ äº”è§’æ˜Ÿ</button>
            <button id="add-arch">â›©ï¸ æ‹±å½¢</button>
            <button id="add-house">ğŸ  å°æˆ¿å­</button>
            <button id="add-knot">ğŸ¥¨ ç»³ç»“</button>
            <button id="add-tile">â¬œ åœ°ç –</button>
        </div>
        
        <div style="margin-top:5px">
            <button id="add-light-btn" style="width:100%">ğŸ’¡ + æ·»åŠ è¾…åŠ©å…‰æº</button>
        </div>

        <span class="group-label">ğŸŒ ç¯å¢ƒè®¾å®š</span>
        <div class="control-row">
            <label>èƒŒæ™¯é¢œè‰²</label>
            <div id="bg-color-trigger" class="color-trigger" style="background-color:#fdfbf7;"></div>
        </div>
        <div class="control-row">
            <label>ç¯å¢ƒå…‰è‰²</label>
            <div id="amb-color-trigger" class="color-trigger" style="background-color:#999999;"></div>
        </div>
        <div class="control-row">
            <label>å¤ªé˜³æ—‹è½¬</label>
            <input type="range" id="light-azimuth" min="0" max="360" value="45">
        </div>
        <div class="control-row">
            <label>å¤ªé˜³é«˜åº¦</label>
            <input type="range" id="light-elevation" min="10" max="90" value="45">
        </div>
        <div class="control-row">
            <label>åœ°å¹³çº¿</label>
            <input type="range" id="grid-height" min="-5" max="2" step="0.1" value="-0.01">
        </div>

        <span class="group-label">ğŸ‘€ æ¸²æŸ“æ¨¡å¼</span>
        <div class="btn-grid" style="grid-template-columns: 1fr 1fr;">
            <button id="mode-pbr" class="active">ğŸŒ‘ PBR (ç‰©ç†)</button>
            <button id="mode-clay">ğŸ—¿ ç™½æ¨¡ (æ³¥å¡‘)</button>
            <button id="mode-normal">ğŸŒˆ æ³•çº¿ (æ£€æµ‹)</button>
            <button id="mode-wire">ğŸ•¸ï¸ çº¿æ¡† (é€è§†)</button>
        </div>

        <span class="group-label">ğŸ”§ å·¥å…·</span>
        <div class="btn-grid">
            <button id="tool-translate" class="tool-btn active">â†”ï¸ ç§»åŠ¨</button>
            <button id="tool-rotate" class="tool-btn">ğŸ”„ æ—‹è½¬</button>
            <button id="tool-scale" class="tool-btn">â†—ï¸ ç¼©æ”¾</button>
        </div>

        <div style="margin-top:15px;">
            <button id="clear-btn" style="width:100%; color:#c0392b; border-color:#e74c3c;">ğŸ—‘ï¸ æ¸…ç©ºåœºæ™¯</button>
            <button id="export-btn" style="width:100%; margin-top:5px; background:#2ecc71; color:white; border:2px solid #27ae60;">ğŸ“¸ ä¿å­˜å›¾ç‰‡</button>
        </div>
    </div>
</div>

<div id="right-panel" class="panel">
    <div id="right-toggle" class="toggle-btn" title="æŠ˜å ">â–¶</div>
    <div class="panel-content">
        <h3>ğŸ“ å±æ€§ & ç»„åˆ</h3>
        
        <div style="position:relative;">
            <div id="no-selection-mask">
                ğŸ‘ˆ Shift + ç‚¹å‡»<br>å¯é€‰ä¸­å¤šä¸ªç‰©ä½“
            </div>
            
            <div id="selection-status">å½“å‰é€‰ä¸­: 0 ä¸ªç‰©ä½“</div>

            <span class="group-label">ğŸ¨ åŸºç¡€å±æ€§ (æ‰¹é‡)</span>
            <div class="control-row">
                <label>å›ºæœ‰è‰²</label>
                <div id="obj-color-trigger" class="color-trigger" style="flex:1; background-color:#ffffff;"></div>
            </div>

            <span class="group-label">ğŸ“ ä½ç½® (XYZ)</span>
            <div class="prop-row">
                <div class="input-group">
                    <input type="number" id="pos-x" step="0.1" placeholder="X">
                    <input type="number" id="pos-y" step="0.1" placeholder="Y">
                    <input type="number" id="pos-z" step="0.1" placeholder="Z">
                </div>
            </div>
            
            <button id="drop-btn">ğŸ‘‡ ä¸€é”®è½åœ° (Y=0)</button>

            <span class="group-label">ğŸ”„ æ—‹è½¬ (è§’åº¦Â°)</span>
            <div class="prop-row">
                <div class="input-group">
                    <input type="number" id="rot-x" step="15" placeholder="X">
                    <input type="number" id="rot-y" step="15" placeholder="Y">
                    <input type="number" id="rot-z" step="15" placeholder="Z">
                </div>
            </div>

            <span class="group-label">ğŸ“ ç¼©æ”¾</span>
            <div class="prop-row">
                <div class="input-group">
                    <input type="number" id="scale-x" step="0.1" placeholder="X">
                    <input type="number" id="scale-y" step="0.1" placeholder="Y">
                    <input type="number" id="scale-z" step="0.1" placeholder="Z">
                </div>
            </div>
        </div>

        <span class="group-label">ğŸ§© åœºæ™¯é¢„è®¾ (14ç§)</span>
        <div class="preset-grid">
            <button id="pre-basic">ğŸ ä¸‰å¤§é¢</button>
            <button id="pre-still">ğŸ é™ç‰©ç©¿æ’</button>
            <button id="pre-tower">ğŸ—¼ å‡ ä½•å¡”</button>
            <button id="pre-arch">â›©ï¸ æ‹±é—¨</button>
            <button id="pre-table">ğŸª‘ æ¡Œæ¤…</button>
            <button id="pre-castle">ğŸ° åŸå ¡</button>
            <button id="pre-snowman">â›„ é›ªäºº</button>
            <button id="pre-pillars">ğŸ›ï¸ åˆ—æŸ±</button>
            <button id="pre-room">ğŸ–¼ï¸ å®¤å†…</button>
            <button id="pre-stairs">ğŸªœ é˜¶æ¢¯</button>
            <button id="pre-snake">ğŸ è›‡å½¢</button>
            <button id="pre-atom">âš›ï¸ åŸå­</button>
            <button id="pre-robot">ğŸ¤– æœºå™¨äºº</button>
            <button id="pre-chaos">ğŸ² ä¹±çŸ³é˜µ</button>
        </div>
    </div>
</div>

<div id="canvas-container"></div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { TransformControls } from 'three/addons/controls/TransformControls.js';

    // ==========================================
    // æ‹¾è‰²å™¨ç±» (æ”¯æŒ HSB / RGB / HEX åˆ‡æ¢ + å¸ç®¡)
    // ==========================================
    class ColorPicker {
        constructor(triggerEl, initialColor, onChange) {
            this.trigger = triggerEl;
            this.onChange = onChange;
            this.h = 0; this.s = 0; this.b = 100;
            this.mode = 'hsb';
            
            this.initUI();
            this.setColorFromHex(initialColor);
            
            this.trigger.onclick = (e) => {
                e.stopPropagation();
                document.querySelectorAll('.cp-popup').forEach(p => {
                    if (p !== this.popup) p.style.display = 'none';
                });
                const rect = this.trigger.getBoundingClientRect();
                let top = rect.bottom + 5;
                if (top + 250 > window.innerHeight) top = rect.top - 250;
                let left = rect.left;
                if (left + 230 > window.innerWidth) left = window.innerWidth - 240;
                
                this.popup.style.top = top + 'px';
                this.popup.style.left = left + 'px';
                this.popup.style.display = (this.popup.style.display === 'block') ? 'none' : 'block';
            };
        }

        initUI() {
            this.popup = document.createElement('div');
            this.popup.className = 'cp-popup';
            document.body.appendChild(this.popup);

            this.svBox = document.createElement('div');
            this.svBox.className = 'cp-sat-val';
            this.cursor = document.createElement('div');
            this.cursor.className = 'cp-cursor';
            this.svBox.appendChild(this.cursor);
            this.popup.appendChild(this.svBox);

            const controls = document.createElement('div');
            controls.className = 'cp-controls';
            
            this.eyedropperBtn = document.createElement('div');
            this.eyedropperBtn.className = 'cp-eyedropper';
            this.eyedropperBtn.title = "å¸å–å±å¹•é¢œè‰²";
            if (!window.EyeDropper) this.eyedropperBtn.classList.add('disabled');
            this.eyedropperBtn.onclick = () => this.pickColor();
            controls.appendChild(this.eyedropperBtn);

            this.preview = document.createElement('div');
            this.preview.className = 'cp-preview';
            controls.appendChild(this.preview);

            this.hueRail = document.createElement('div');
            this.hueRail.className = 'cp-hue-rail';
            this.hueThumb = document.createElement('div');
            this.hueThumb.className = 'cp-hue-thumb';
            this.hueRail.appendChild(this.hueThumb);
            controls.appendChild(this.hueRail);

            this.popup.appendChild(controls);

            this.inputsContainer = document.createElement('div');
            this.inputsContainer.className = 'cp-inputs-container';
            this.popup.appendChild(this.inputsContainer);

            this.renderInputs();

            this.bindDrag(this.svBox, (x, y) => {
                this.s = x * 100;
                this.b = (1 - y) * 100;
                this.updateUI();
                this.fireChange();
            });

            this.bindDrag(this.hueRail, (x, y) => {
                this.h = x * 360;
                this.updateUI();
                this.fireChange();
            });

            window.addEventListener('mousedown', (e) => {
                if (!this.popup.contains(e.target) && e.target !== this.trigger) {
                    this.popup.style.display = 'none';
                }
            });
        }

        async pickColor() {
            if (!window.EyeDropper) { alert("æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒå¸ç®¡å·¥å…·"); return; }
            try {
                const ed = new EyeDropper();
                const result = await ed.open();
                this.setColorFromHex(result.sRGBHex);
                this.fireChange();
            } catch (e) { /* Cancelled */ }
        }

        toggleMode() {
            const modes = ['hsb', 'rgb', 'hex'];
            const idx = modes.indexOf(this.mode);
            this.mode = modes[(idx + 1) % modes.length];
            this.renderInputs();
            this.updateUI();
        }

        renderInputs() {
            this.inputsContainer.innerHTML = '';
            const labels = { 'hsb': ['H', 'S', 'B'], 'rgb': ['R', 'G', 'B'], 'hex': ['HEX'] };
            const currentLabels = labels[this.mode];

            currentLabels.forEach((lbl, idx) => {
                const group = document.createElement('div');
                group.className = 'cp-input-group';
                
                const input = document.createElement('input');
                input.className = 'cp-num-input';
                
                if (this.mode === 'hex') {
                    input.type = 'text';
                    input.onchange = () => this.handleHexInput(input.value);
                } else {
                    input.type = 'number';
                    input.onchange = () => this.handleNumInput(idx, input.value);
                }

                const labelDiv = document.createElement('div');
                labelDiv.className = 'cp-label';
                labelDiv.innerHTML = lbl + (idx === currentLabels.length - 1 ? ' <span class="cp-switch-icon">â€º</span>' : '');
                if (idx === currentLabels.length - 1) {
                    labelDiv.onclick = () => this.toggleMode();
                    labelDiv.title = "ç‚¹å‡»åˆ‡æ¢æ¨¡å¼ (HSB/RGB/HEX)";
                }

                group.appendChild(input);
                group.appendChild(labelDiv);
                this.inputsContainer.appendChild(group);
            });
        }

        handleNumInput(idx, val) {
            val = parseInt(val);
            if (isNaN(val)) return;

            if (this.mode === 'hsb') {
                if (idx === 0) this.h = (val % 360 + 360) % 360;
                if (idx === 1) this.s = Math.max(0, Math.min(100, val));
                if (idx === 2) this.b = Math.max(0, Math.min(100, val));
            } else if (this.mode === 'rgb') {
                const rgb = this.hsbToRgbObj(this.h, this.s, this.b);
                if (idx === 0) rgb.r = Math.max(0, Math.min(255, val));
                if (idx === 1) rgb.g = Math.max(0, Math.min(255, val));
                if (idx === 2) rgb.b = Math.max(0, Math.min(255, val));
                this.setColorFromRgb(rgb.r, rgb.g, rgb.b);
            }
            this.updateUI();
            this.fireChange();
        }

        handleHexInput(val) {
            if (/^#[0-9A-Fa-f]{6}$/.test(val) || /^[0-9A-Fa-f]{6}$/.test(val)) {
                if (!val.startsWith('#')) val = '#' + val;
                this.setColorFromHex(val);
                this.fireChange();
            }
        }

        updateUI() {
            this.svBox.style.backgroundColor = `hsl(${this.h}, 100%, 50%)`;
            this.cursor.style.left = this.s + '%';
            this.cursor.style.top = (100 - this.b) + '%';
            this.hueThumb.style.left = (this.h / 360 * 100) + '%';
            const hex = this.hsbToHex(this.h, this.s, this.b);
            this.trigger.style.backgroundColor = hex;
            this.preview.style.backgroundColor = hex;

            const inputs = this.inputsContainer.querySelectorAll('input');
            if (this.mode === 'hsb') {
                inputs[0].value = Math.round(this.h);
                inputs[1].value = Math.round(this.s);
                inputs[2].value = Math.round(this.b);
            } else if (this.mode === 'rgb') {
                const rgb = this.hsbToRgbObj(this.h, this.s, this.b);
                inputs[0].value = rgb.r;
                inputs[1].value = rgb.g;
                inputs[2].value = rgb.b;
            } else {
                inputs[0].value = hex;
            }
        }

        bindDrag(el, callback) {
            const handle = (e) => {
                e.preventDefault();
                const rect = el.getBoundingClientRect();
                let x = (e.clientX - rect.left) / rect.width;
                let y = (e.clientY - rect.top) / rect.height;
                x = Math.max(0, Math.min(1, x));
                y = Math.max(0, Math.min(1, y));
                callback(x, y);
            };
            el.addEventListener('mousedown', (e) => {
                handle(e);
                const move = (em) => handle(em);
                const up = () => { window.removeEventListener('mousemove', move); window.removeEventListener('mouseup', up); };
                window.addEventListener('mousemove', move); window.addEventListener('mouseup', up);
            });
        }

        setColorFromHex(hex) {
            const rgb = this.hexToRgbObj(hex);
            this.setColorFromRgb(rgb.r, rgb.g, rgb.b);
        }

        setColorFromRgb(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, v = max;
            let d = max - min;
            s = max === 0 ? 0 : d / max;
            if (max === min) h = 0;
            else {
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            this.h = h * 360; this.s = s * 100; this.b = v * 100;
            this.updateUI();
        }

        hsbToRgbObj(h, s, b) {
            s /= 100; b /= 100;
            const k = (n) => (n + h / 60) % 6;
            const f = (n) => b * (1 - s * Math.max(0, Math.min(k(n), 4 - k(n), 1)));
            return { r: Math.round(f(5) * 255), g: Math.round(f(3) * 255), b: Math.round(f(1) * 255) };
        }

        hsbToHex(h, s, b) {
            const rgb = this.hsbToRgbObj(h, s, b);
            const toHex = (x) => { const hex = x.toString(16); return hex.length === 1 ? '0' + hex : hex; };
            return `#${toHex(rgb.r)}${toHex(rgb.g)}${toHex(rgb.b)}`;
        }

        hexToRgbObj(hex) {
            if (hex.startsWith('#')) hex = hex.slice(1);
            if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
            const bigInt = parseInt(hex, 16);
            return { r: (bigInt >> 16) & 255, g: (bigInt >> 8) & 255, b: bigInt & 255 };
        }

        fireChange() { if (this.onChange) this.onChange(this.hsbToHex(this.h, this.s, this.b)); }
    }


    // ==========================================
    // ä¸»é€»è¾‘
    // ==========================================

    const allObjects = []; 
    let currentMode = 'pbr'; 
    const DEFAULT_COLOR = '#fdfbf7'; 
    let selectedObjects = [];
    let transformControl;
    let gridHelper;
    let blackLineMat; 
    let wireStructureMat;

    // === æ’¤é”€ç³»ç»Ÿ ===
    const historyStack = [];
    let historyPointer = -1;
    let isRestoring = false;

    function saveState() {
        if (isRestoring) return;
        if (historyPointer < historyStack.length - 1) { historyStack.splice(historyPointer + 1); }
        const state = allObjects.map(obj => {
            const worldPos = new THREE.Vector3(); const worldQuat = new THREE.Quaternion(); const worldScale = new THREE.Vector3();
            obj.getWorldPosition(worldPos); obj.getWorldQuaternion(worldQuat); obj.getWorldScale(worldScale);
            const rotation = new THREE.Euler().setFromQuaternion(worldQuat);
            return {
                type: obj.userData.type, pos: worldPos.toArray(), rot: rotation.toArray(), scale: worldScale.toArray(), color: obj.userData.baseColor
            };
        });
        const selectionIndices = selectedObjects.map(obj => allObjects.indexOf(obj));
        const fullState = { scene: state, selection: selectionIndices };
        const stateStr = JSON.stringify(fullState);
        if (historyPointer >= 0 && JSON.stringify(historyStack[historyPointer]) === stateStr) return;
        historyStack.push(fullState); historyPointer++;
        if (historyStack.length > 20) { historyStack.shift(); historyPointer--; }
        updateHistoryButtons();
    }

    function restoreState(stateObj) {
        if (!stateObj) return;
        isRestoring = true; clearScene(false);
        const stateData = stateObj.scene || []; const selectionData = stateObj.selection || [];
        stateData.forEach(data => {
            try {
                if(data.type === 'light') { addPointLightInternal({x:data.pos[0], y:data.pos[1], z:data.pos[2]}, data.color); } 
                else { addGeoInternal(data.type, {x:data.pos[0], y:data.pos[1], z:data.pos[2]}, {x:data.rot[0], y:data.rot[1], z:data.rot[2]}, {x:data.scale[0], y:data.scale[1], z:data.scale[2]}, data.color); }
            } catch(e) { console.error(e); }
        });
        selectedObjects = [];
        selectionData.forEach(idx => { if (allObjects[idx]) selectedObjects.push(allObjects[idx]); });
        updateSelectionGroup(); updateUI();
        isRestoring = false; updateHistoryButtons();
    }

    function undo() { if (historyPointer > 0) { historyPointer--; restoreState(historyStack[historyPointer]); } }
    function redo() { if (historyPointer < historyStack.length - 1) { historyPointer++; restoreState(historyStack[historyPointer]); } }
    function updateHistoryButtons() {
        document.getElementById('btn-undo').disabled = (historyPointer <= 0);
        document.getElementById('btn-redo').disabled = (historyPointer >= historyStack.length - 1);
    }
    document.getElementById('btn-undo').onclick = undo; document.getElementById('btn-redo').onclick = redo;

    // === æè´¨å®šä¹‰ ===
    blackLineMat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1.5 });
    wireStructureMat = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 });
    
    function getMaterials(colorHex, mode) {
        const color = new THREE.Color(colorHex);
        if (mode === 'pbr') return new THREE.MeshStandardMaterial({ color: color, roughness: 0.6, metalness: 0.05 }); 
        else if (mode === 'clay') return new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 1.0, metalness: 0.0 });
        else if (mode === 'normal') return new THREE.MeshNormalMaterial();
        else if (mode === 'wire') return new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.15, depthWrite: false, side: THREE.DoubleSide });
        else return new THREE.MeshStandardMaterial({ color: color, roughness: 0.6, metalness: 0.05 });
    }

    // === æ›´æ–°æè´¨ ===
    window.updateMaterials = function() {
        allObjects.forEach(obj => {
            if (obj.userData.type !== 'light') {
                obj.material = getMaterials(obj.userData.baseColor, currentMode);
                const structure = obj.children.find(c => c.userData.isStructure);
                const outline = obj.children.find(c => c.userData.isOutline);
                if(outline) outline.visible = false;
                if(structure) structure.visible = false;
                if (currentMode === 'wire') {
                    if(structure) { structure.visible = true; structure.material = blackLineMat; } 
                    else if(outline) { outline.visible = true; outline.material = blackLineMat; }
                } 
                obj.castShadow = true; obj.receiveShadow = (currentMode !== 'wire');
            }
        });
        if(gridHelper) gridHelper.visible = true;
    };

    function safeBind(id, action) { const btn = document.getElementById(id); if (btn) btn.onclick = action; }
    safeBind('left-toggle', () => { const p = document.getElementById('left-panel'); p.classList.toggle('collapsed'); document.getElementById('left-toggle').innerText = p.classList.contains('collapsed') ? 'â–¶' : 'â—€'; });
    safeBind('right-toggle', () => { const p = document.getElementById('right-panel'); p.classList.toggle('collapsed'); document.getElementById('right-toggle').innerText = p.classList.contains('collapsed') ? 'â—€' : 'â–¶'; });

    // === åœºæ™¯ ===
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xfdfbf7);
    scene.fog = new THREE.Fog(0xfdfbf7, 10, 60);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(10, 8, 10);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
    container.appendChild(renderer.domElement);

    // === ç¯å…‰ ===
    const ambientLight = new THREE.AmbientLight(0x999999, 0.7); scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(5, 8, 5); dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
    dirLight.shadow.bias = -0.00005; dirLight.shadow.normalBias = 0.02; 
    scene.add(dirLight);
    const sunHelper = new THREE.Mesh(new THREE.SphereGeometry(0.3,8,8), new THREE.MeshBasicMaterial({color:0xffcc00, wireframe:true}));
    scene.add(sunHelper);

    gridHelper = new THREE.GridHelper(30, 30, 0xa4b0be, 0xdfe4ea); 
    gridHelper.position.y = -0.01; scene.add(gridHelper);
    
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.ShadowMaterial({ opacity: 0.2, color: 0x2c3e50 }));
    ground.rotation.x = -Math.PI/2; ground.position.y = -0.02; ground.receiveShadow = true; scene.add(ground);
    
    const gridInput = document.getElementById('grid-height');
    if(gridInput) { gridInput.addEventListener('input', () => { const h = parseFloat(gridInput.value); gridHelper.position.y = h; ground.position.y = h - 0.01; }); gridHelper.position.y = -0.01; ground.position.y = -0.02; }

    // === æ¥å…¥è‡ªå®šä¹‰æ‹¾è‰²å™¨ ===
    new ColorPicker(document.getElementById('bg-color-trigger'), '#fdfbf7', (hex) => {
        scene.background = new THREE.Color(hex); scene.fog.color = new THREE.Color(hex);
    });
    
    new ColorPicker(document.getElementById('amb-color-trigger'), '#999999', (hex) => {
        ambientLight.color.set(hex);
    });

    const objColorPicker = new ColorPicker(document.getElementById('obj-color-trigger'), '#ffffff', (hex) => {
        selectedObjects.forEach(obj => {
            obj.userData.baseColor = hex;
            if(obj.userData.type !== 'light') { if(currentMode!=='wire' && currentMode!=='clay' && currentMode!=='normal') obj.material.color.set(hex); } 
            else { obj.material.color.set(hex); if(obj.children[0].isLight) obj.children[0].color.set(hex); }
        });
        saveState();
    });

    // === æ§åˆ¶å™¨ ===
    const orbit = new OrbitControls(camera, renderer.domElement);
    transformControl = new TransformControls(camera, renderer.domElement);
    transformControl.addEventListener('dragging-changed', e => { orbit.enabled = !e.value; if (!e.value) saveState(); });
    scene.add(transformControl);

    const selectionGroup = new THREE.Group();
    scene.add(selectionGroup);

    function attachToGroup(obj) { if (obj.parent !== scene) scene.attach(obj); selectionGroup.attach(obj); }
    function detachFromGroup(obj) { scene.attach(obj); }

    function updateSelectionGroup() {
        [...selectionGroup.children].forEach(child => detachFromGroup(child));
        if (selectedObjects.length === 0) {
            transformControl.detach(); selectionGroup.position.set(0,0,0); selectionGroup.rotation.set(0,0,0); selectionGroup.scale.set(1,1,1); return;
        }
        const center = new THREE.Vector3();
        selectedObjects.forEach(obj => center.add(obj.position));
        center.divideScalar(selectedObjects.length);
        selectionGroup.position.copy(center); selectionGroup.rotation.set(0,0,0); selectionGroup.scale.set(1,1,1);
        selectedObjects.forEach(obj => attachToGroup(obj));
        transformControl.attach(selectionGroup);
    }
    transformControl.addEventListener('change', () => { if (selectedObjects.length > 0) updateUIFromObject(selectionGroup); });

    // === ç‰©ä½“ç®¡ç† ===
    function getRandomColor() { return `hsl(${Math.floor(Math.random()*360)}, 75%, 75%)`; }
    const isSmooth = (type) => ['sphere', 'cylinder', 'cone', 'hemi', 'capsule', 'torus', 'ring', 'tube', 'knot', 'arch'].includes(type);

    function addGeoInternal(type, pos, rot, scale, colorStr) {
        let geo;
        switch(type) {
            case 'cube': geo = new THREE.BoxGeometry(2,2,2); break;
            case 'sphere': geo = new THREE.SphereGeometry(1.3, 32, 32); break;
            case 'cone': geo = new THREE.ConeGeometry(1.3, 2.8, 32); break;
            case 'cylinder': geo = new THREE.CylinderGeometry(1.1, 1.1, 2.8, 32); break;
            case 'hemi': geo = new THREE.SphereGeometry(1.3, 32, 16, 0, Math.PI*2, 0, Math.PI/2); break;
            case 'capsule': geo = new THREE.CapsuleGeometry(0.8, 1.5, 4, 16); break;
            case 'torus': geo = new THREE.TorusGeometry(1.0, 0.4, 16, 48); break;
            case 'ring': geo = new THREE.TorusGeometry(1.2, 0.1, 8, 48); geo.rotateX(Math.PI/2); break;
            case 'lshape': 
                const shape = new THREE.Shape();
                shape.moveTo(0,0); shape.lineTo(0,3); shape.lineTo(1,3); shape.lineTo(1,1); shape.lineTo(3,1); shape.lineTo(3,0); shape.lineTo(0,0);
                geo = new THREE.ExtrudeGeometry(shape, { depth: 1, bevelEnabled: false }); geo.center(); break;
            case 'pyramid': geo = new THREE.CylinderGeometry(0, 1.5, 2.5, 4, 1); if(!rot) geo.rotateY(Math.PI/4); break;
            case 'prism': geo = new THREE.CylinderGeometry(1, 1, 2.5, 3); break;
            case 'wedge': geo = new THREE.CylinderGeometry(1, 1, 2, 3); geo.rotateZ(Math.PI/2); break;
            case 'cross': 
                const s2 = new THREE.Shape();
                s2.moveTo(1,0); s2.lineTo(2,0); s2.lineTo(2,1); s2.lineTo(3,1); s2.lineTo(3,2); s2.lineTo(2,2); s2.lineTo(2,3); s2.lineTo(1,3); s2.lineTo(1,2); s2.lineTo(0,2); s2.lineTo(0,1); s2.lineTo(1,1); s2.lineTo(1,0);
                geo = new THREE.ExtrudeGeometry(s2, {depth:1, bevelEnabled:false}); geo.center(); break;
            case 'star':
                const s3 = new THREE.Shape();
                const pts = [];
                for(let i=0;i<10;i++){ const r = (i%2===0)? 1.5 : 0.6; const a = i/10 * Math.PI*2; pts.push(new THREE.Vector2(Math.cos(a)*r, Math.sin(a)*r)); }
                s3.setFromPoints(pts); geo = new THREE.ExtrudeGeometry(s3, {depth:1, bevelEnabled:false}); break;
            case 'arch': geo = new THREE.TorusGeometry(1.5, 0.5, 16, 32, Math.PI); break;
            case 'house': geo = new THREE.CylinderGeometry(0, 1.5, 2, 5, 1); break;
            case 'knot': geo = new THREE.TorusKnotGeometry(0.8, 0.25, 64, 16); break;
            case 'tile': geo = new THREE.BoxGeometry(3, 0.2, 3); break;
            default: geo = new THREE.BoxGeometry(1,1,1);
        }
        
        const c = colorStr || DEFAULT_COLOR;
        const hex = new THREE.Color(c).getHexString();
        const mesh = new THREE.Mesh(geo, getMaterials('#'+hex, currentMode));
        // å…³é”®ä¿®å¤ï¼šæ­£ç¡®å­˜å‚¨ type
        mesh.userData = { type: type, baseColor: '#'+hex };
        mesh.castShadow = true; mesh.receiveShadow = true;
        if(type === 'tube') mesh.material.side = THREE.DoubleSide; 

        if (!isSmooth(type)) {
            const edges = new THREE.EdgesGeometry(geo);
            const outline = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x2c3e50 }));
            outline.userData.isOutline = true; 
            outline.visible = false; 
            mesh.add(outline);
        }

        if (isSmooth(type)) {
            const wireGeo = new THREE.WireframeGeometry(geo);
            const structure = new THREE.LineSegments(wireGeo, blackLineMat);
            structure.userData.isStructure = true;
            structure.visible = false;
            mesh.add(structure);
        }

        if(pos) mesh.position.set(pos.x, pos.y, pos.z); else mesh.position.set((Math.random()-0.5)*4, 0, (Math.random()-0.5)*4);
        if(rot) mesh.rotation.set(rot.x, rot.y, rot.z);
        if(scale) mesh.scale.set(scale.x, scale.y, scale.z);
        scene.add(mesh); allObjects.push(mesh);
        
        return mesh;
    }

    function addGeo(type, pos, rot, scale, colorStr) {
        const mesh = addGeoInternal(type, pos, rot, scale, colorStr);
        if(!isRestoring) {
            selectedObjects = [mesh];
            updateSelectionGroup(); updateUI(); updateMaterials(); 
            saveState();
        }
        return mesh;
    }

    function addPointLightInternal(pos, colorStr) {
        const color = colorStr || '#ffaa00';
        const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16), new THREE.MeshBasicMaterial({color:color}));
        const light = new THREE.PointLight(color, 0.8, 15);
        light.castShadow = true; light.shadow.bias = -0.0001; light.shadow.normalBias = 0.02; bulb.add(light);
        bulb.add(new THREE.LineSegments(new THREE.WireframeGeometry(new THREE.SphereGeometry(0.5,8,8)), new THREE.LineBasicMaterial({color:0x444444})));
        bulb.position.set(pos.x, pos.y, pos.z);
        bulb.userData = { type: 'light', baseColor: color };
        scene.add(bulb); allObjects.push(bulb);
        return bulb;
    }

    function addPointLight(pos={x:0, y:3, z:0}) {
        const bulb = addPointLightInternal(pos);
        if(!isRestoring) { selectedObjects = [bulb]; updateSelectionGroup(); updateUI(); saveState(); }
    }

    // === UI ===
    const uiMask = document.getElementById('no-selection-mask');
    const statusText = document.getElementById('selection-status');
    const inputs = {
        px: document.getElementById('pos-x'), py: document.getElementById('pos-y'), pz: document.getElementById('pos-z'),
        rx: document.getElementById('rot-x'), ry: document.getElementById('rot-y'), rz: document.getElementById('rot-z'),
        sx: document.getElementById('scale-x'), sy: document.getElementById('scale-y'), sz: document.getElementById('scale-z')
    };

    function updateUI() {
        if (selectedObjects.length === 0) { uiMask.style.display = 'flex'; statusText.textContent = "å½“å‰é€‰ä¸­: 0 ä¸ªç‰©ä½“"; } 
        else { 
            uiMask.style.display = 'none'; statusText.textContent = `å½“å‰é€‰ä¸­: ${selectedObjects.length} ä¸ªç‰©ä½“`; 
            updateUIFromObject(selectionGroup);
            const color = selectedObjects[0].userData.baseColor || '#ffffff';
            objColorPicker.setColorFromHex(color);
        }
    }

    function updateUIFromObject(obj) {
        inputs.px.value = parseFloat(obj.position.x.toFixed(2)); inputs.py.value = parseFloat(obj.position.y.toFixed(2)); inputs.pz.value = parseFloat(obj.position.z.toFixed(2));
        const deg = 180/Math.PI;
        inputs.rx.value = Math.round(obj.rotation.x * deg); inputs.ry.value = Math.round(obj.rotation.y * deg); inputs.rz.value = Math.round(obj.rotation.z * deg);
        inputs.sx.value = parseFloat(obj.scale.x.toFixed(2)); inputs.sy.value = parseFloat(obj.scale.y.toFixed(2)); inputs.sz.value = parseFloat(obj.scale.z.toFixed(2));
    }

    function updateObjectFromUI() {
        if(selectedObjects.length === 0) return;
        selectionGroup.position.set(parseFloat(inputs.px.value)||0, parseFloat(inputs.py.value)||0, parseFloat(inputs.pz.value)||0);
        const rad = Math.PI/180;
        selectionGroup.rotation.set((parseFloat(inputs.rx.value)||0)*rad, (parseFloat(inputs.ry.value)||0)*rad, (parseFloat(inputs.rz.value)||0)*rad);
        selectionGroup.scale.set(parseFloat(inputs.sx.value)||1, parseFloat(inputs.sy.value)||1, parseFloat(inputs.sz.value)||1);
    }
    Object.values(inputs).forEach(i => { if(i) { i.addEventListener('input', updateObjectFromUI); i.addEventListener('change', () => { updateObjectFromUI(); saveState(); }); } });

    safeBind('drop-btn', () => {
        if(selectedObjects.length === 0) return;
        updateSelectionGroup(); [...selectionGroup.children].forEach(c => scene.attach(c));
        const tempGroup = new THREE.Group(); scene.add(tempGroup);
        selectedObjects.forEach(obj => tempGroup.attach(obj));
        const box = new THREE.Box3().setFromObject(tempGroup);
        const bottomY = box.min.y;
        const gridH = parseFloat(document.getElementById('grid-height').value);
        tempGroup.position.y += (gridH - bottomY);
        [...tempGroup.children].forEach(c => scene.attach(c)); scene.remove(tempGroup);
        updateSelectionGroup(); updateUI(); saveState();
    });

    const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2();
    window.addEventListener('mousedown', (e) => {
        if(e.target.closest('.panel') || e.target.closest('.cp-popup')) return;
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left)/rect.width)*2-1; mouse.y = -((e.clientY-rect.top)/rect.height)*2+1;
        raycaster.setFromCamera(mouse, camera);
        const targetObjects = [...allObjects];
        const intersects = raycaster.intersectObjects(targetObjects, false);
        if(intersects.length > 0) {
            const hit = intersects[0].object;
            if (e.shiftKey) { const idx = selectedObjects.indexOf(hit); if (idx > -1) selectedObjects.splice(idx, 1); else selectedObjects.push(hit); } 
            else { selectedObjects = [hit]; }
        } else { if (!e.shiftKey) selectedObjects = []; }
        updateSelectionGroup(); updateUI();
    });

    // === åŠŸèƒ½ç»‘å®š ===
    function clearScene(triggerSave = true) { 
        updateSelectionGroup(); [...selectionGroup.children].forEach(c => scene.attach(c));
        allObjects.forEach(o => scene.remove(o)); allObjects.length=0; selectedObjects = []; 
        updateSelectionGroup(); updateUI();
        if(triggerSave) saveState();
    }
    
    const btnBindings = {
        'add-cube': () => addGeo('cube'),
        'add-sphere': () => addGeo('sphere'),
        'add-cone': () => addGeo('cone'),
        'add-cylinder': () => addGeo('cylinder'),
        'add-hemi': () => addGeo('hemi'),
        'add-capsule': () => addGeo('capsule'),
        'add-torus': () => addGeo('torus'),
        'add-ring': () => addGeo('ring'),
        'add-lshape': () => addGeo('lshape'),
        'add-pyramid': () => addGeo('pyramid'),
        'add-prism': () => addGeo('prism'),
        'add-wedge': () => addGeo('wedge'),
        'add-cross': () => addGeo('cross'),
        'add-star': () => addGeo('star'),
        'add-arch': () => addGeo('arch'),
        'add-house': () => addGeo('house'),
        'add-knot': () => addGeo('knot'),
        'add-tile': () => addGeo('tile')
    };
    Object.keys(btnBindings).forEach(id => safeBind(id, btnBindings[id]));
    safeBind('add-light-btn', () => addPointLight());

    function loadPreset(fn) { isRestoring = true; clearScene(false); isRestoring = false; fn(); saveState(); }

    safeBind('pre-basic', () => loadPreset(() => { addGeo('cube', {x:-1.5,y:0,z:0}); addGeo('sphere', {x:1.5,y:0,z:0}); addGeo('cone', {x:0,y:0,z:1.5}); }));
    safeBind('pre-still', () => loadPreset(() => { addGeo('cube', {x:-1,y:0,z:0}, {x:0,y:0.5,z:0}); addGeo('cone', {x:1,y:0,z:0.5}); addGeo('sphere', {x:0,y:0,z:-1.5}); }));
    safeBind('pre-tower', () => loadPreset(() => { addGeo('cube', {x:0,y:-1,z:0}, null, {x:2,y:0.5,z:2}); addGeo('cylinder', {x:0,y:0.5,z:0}, null, {x:1,y:1,z:1}); addGeo('cone', {x:0,y:2.5,z:0}, null, {x:1.2,y:1,z:1.2}); }));
    safeBind('pre-arch', () => loadPreset(() => { addGeo('cube', {x:-1.5,y:1,z:0}, null, {x:0.5,y:2,z:0.5}); addGeo('cube', {x:1.5,y:1,z:0}, null, {x:0.5,y:2,z:0.5}); addGeo('cube', {x:0,y:3.2,z:0}, null, {x:4,y:0.5,z:0.8}); }));
    safeBind('pre-balance', () => loadPreset(() => { addGeo('sphere', {x:0,y:-0.5,z:0}, null, {x:1,y:1,z:1}); addGeo('cube', {x:0,y:1.2,z:0}, {x:0.2,y:0,z:0.2}, {x:2.5,y:0.2,z:0.5}); addGeo('cone', {x:-1,y:2.5,z:0}, null, {x:0.5,y:0.8,z:0.5}); }));
    safeBind('pre-wall', () => loadPreset(() => { for(let i=0;i<3;i++) for(let j=0;j<3;j++) addGeo('cube', {x:(i-1)*2.1, y:j*2.1-1, z:-2}); }));
    safeBind('pre-stairs', () => loadPreset(() => { for(let i=0;i<5;i++) addGeo('cube', {x:i-2, y:i*0.5-1, z:i-2}, null, {x:1,y:0.5,z:1}); }));
    safeBind('pre-snake', () => loadPreset(() => { for(let i=0;i<6;i++) addGeo('sphere', {x:Math.sin(i)*1.5, y:0, z:i*1.2-3}, null, {x:0.6,y:0.6,z:0.6}); }));
    safeBind('pre-tunnel', () => loadPreset(() => { for(let i=0;i<5;i++) addGeo('torus', {x:0,y:0,z:i*1.5-3}); }));
    safeBind('pre-atom', () => loadPreset(() => { addGeo('sphere', {x:0,y:0,z:0}); addGeo('sphere', {x:2.5,y:0,z:0}, null, {x:0.3,y:0.3,z:0.3}); addGeo('sphere', {x:-2.5,y:0,z:0}, null, {x:0.3,y:0.3,z:0.3}); addGeo('sphere', {x:0,y:0,z:2.5}, null, {x:0.3,y:0.3,z:0.3}); }));
    safeBind('pre-robot', () => loadPreset(() => { addGeo('cube', {x:0,y:0,z:0}, null, {x:1.5,y:2,z:1}); addGeo('cube', {x:0,y:2.5,z:0}, null, {x:1,y:1,z:1}); addGeo('cylinder', {x:-1,y:0,z:0}, {x:0,y:0,z:1.5}, {x:0.3,y:1.5,z:0.3}); addGeo('cylinder', {x:1,y:0,z:0}, {x:0,y:0,z:-1.5}, {x:0.3,y:1.5,z:0.3}); addGeo('cube', {x:-0.5,y:-2,z:0}, null, {x:0.5,y:2,z:0.5}); addGeo('cube', {x:0.5,y:-2,z:0}, null, {x:0.5,y:2,z:0.5}); }));
    safeBind('pre-chaos', () => loadPreset(() => { for(let i=0;i<10;i++) addGeo(['cube','sphere','cone'][Math.floor(Math.random()*3)], {x:(Math.random()-0.5)*5, y:(Math.random())*3, z:(Math.random()-0.5)*5}, {x:Math.random(),y:Math.random(),z:Math.random()}); }));
    safeBind('pre-table', () => loadPreset(() => { addGeo('cube',{x:0,y:0,z:0},null,{x:4,y:0.2,z:3}); addGeo('cube',{x:1.5,y:-1.5,z:1},null,{x:0.2,y:3,z:0.2}); addGeo('cube',{x:-1.5,y:-1.5,z:1},null,{x:0.2,y:3,z:0.2}); addGeo('cube',{x:1.5,y:-1.5,z:-1},null,{x:0.2,y:3,z:0.2}); addGeo('cube',{x:-1.5,y:-1.5,z:-1},null,{x:0.2,y:3,z:0.2}); addGeo('cube',{x:0,y:-1,z:2.5},null,{x:1.5,y:0.1,z:1.5}); addGeo('cube',{x:0,y:-0.2,z:3.2},{x:0.2,y:0,z:0},{x:1.5,y:1.5,z:0.1}); }));
    safeBind('pre-castle', () => loadPreset(() => { addGeo('cylinder',{x:-2,y:0,z:-2},null,{x:1,y:2,z:1}); addGeo('cone',{x:-2,y:2.5,z:-2}); addGeo('cylinder',{x:2,y:0,z:-2},null,{x:1,y:2,z:1}); addGeo('cone',{x:2,y:2.5,z:-2}); addGeo('cylinder',{x:-2,y:0,z:2},null,{x:1,y:2,z:1}); addGeo('cone',{x:-2,y:2.5,z:2}); addGeo('cylinder',{x:2,y:0,z:2},null,{x:1,y:2,z:1}); addGeo('cone',{x:2,y:2.5,z:2}); addGeo('cube',{x:0,y:-0.5,z:0},null,{x:4,y:1.5,z:4}); }));
    safeBind('pre-snowman', () => loadPreset(() => { addGeo('sphere',{x:0,y:-1.5,z:0},null,{x:1.5,y:1.5,z:1.5}); addGeo('sphere',{x:0,y:1,z:0},null,{x:1.1,y:1.1,z:1.1}); addGeo('sphere',{x:0,y:2.8,z:0},null,{x:0.8,y:0.8,z:0.8}); addGeo('cone',{x:0,y:3.5,z:0.8},{x:Math.PI/2,y:0,z:0},{x:0.2,y:1,z:0.2}); }));
    safeBind('pre-pillars', () => loadPreset(() => { for(let i=0;i<4;i++){ addGeo('cylinder',{x:i*2-3, y:0, z:-2},null,{x:0.5,y:3,z:0.5}); addGeo('cylinder',{x:i*2-3, y:0, z:2},null,{x:0.5,y:3,z:0.5}); } addGeo('cube',{x:0,y:1.7,z:0},null,{x:8,y:0.5,z:6}); }));
    safeBind('pre-room', () => loadPreset(() => { addGeo('cube',{x:0,y:0,z:-3},null,{x:8,y:4,z:0.2}); addGeo('cube',{x:-4,y:0,z:0},null,{x:0.2,y:4,z:6}); addGeo('tile',{x:0,y:-2,z:0},null,{x:3,y:1,z:2}); addGeo('cube',{x:0,y:-1.5,z:0}); addGeo('sphere',{x:-1,y:-1,z:1}); }));

    const modes = ['pbr', 'clay', 'normal', 'wire'];
    modes.forEach(m => {
        safeBind('mode-'+m, () => { 
            currentMode = m; 
            modes.forEach(mm=>document.getElementById('mode-'+mm).classList.remove('active')); 
            document.getElementById('mode-'+m).classList.add('active'); 
            updateMaterials(); 
        });
    });
    
    ['translate', 'rotate', 'scale'].forEach(t => {
        safeBind('tool-'+t, () => {
            transformControl.setMode(t);
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('tool-'+t).classList.add('active');
        });
    });

    safeBind('clear-btn', () => clearScene(true));
    
    window.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); return; }
        if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); return; }
        if(e.key === 'w') document.getElementById('tool-translate').click();
        if(e.key === 'e') document.getElementById('tool-rotate').click();
        if(e.key === 'r') document.getElementById('tool-scale').click();
        if((e.key === 'Delete'||e.key === 'Backspace') && selectedObjects.length>0) { 
            updateSelectionGroup(); [...selectionGroup.children].forEach(c => scene.attach(c)); 
            selectedObjects.forEach(o => { scene.remove(o); allObjects.splice(allObjects.indexOf(o), 1); });
            selectedObjects = []; updateSelectionGroup(); updateUI();
            saveState();
        }
    });

    function updateSun() {
        const azEl = document.getElementById('light-azimuth');
        const elEl = document.getElementById('light-elevation');
        if(azEl && elEl) {
            const az = azEl.value * (Math.PI/180);
            const el = (90-elEl.value) * (Math.PI/180);
            dirLight.position.set(8*Math.sin(el)*Math.sin(az), 8*Math.cos(el), 8*Math.sin(el)*Math.cos(az));
            sunHelper.position.copy(dirLight.position); sunHelper.lookAt(0,0,0);
            dirLight.updateMatrixWorld();
        }
    }
    ['light-azimuth','light-elevation'].forEach(id => {
        const el = document.getElementById(id);
        if(el) el.addEventListener('input', updateSun);
    });
    
    const ambEl = document.getElementById('ambient-color');
    if(ambEl) ambEl.addEventListener('input', e => ambientLight.color.set(e.target.value));

    safeBind('export-btn', () => {
        transformControl.detach(); sunHelper.visible=false; allObjects.forEach(o => { if(o.userData.type==='light') o.children[1].visible=false; });
        renderer.render(scene, camera);
        const link = document.createElement('a'); link.download = 'sketch-v20.png'; link.href = renderer.domElement.toDataURL('image/png'); link.click();
        sunHelper.visible=true; if(selectedObjects.length>0) transformControl.attach(selectionGroup); allObjects.forEach(o => { if(o.userData.type==='light') o.children[1].visible=true; });
    });

    saveState();
    function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
    animate();
    window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

</script>
</body>
</html>
